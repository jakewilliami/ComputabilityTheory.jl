var documenterSearchIndex = {"docs":
[{"location":"#ComputabilityTheory.jl-Documentation","page":"Index","title":"ComputabilityTheory.jl Documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = ComputabilityTheory\nDocTestSetup = quote\n    using ComputabilityTheory\nend","category":"page"},{"location":"#Adding-ComputabilityTheory.jl","page":"Index","title":"Adding ComputabilityTheory.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"ComputabilityTheory\")","category":"page"},{"location":"#Documentation","page":"Index","title":"Documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [ComputabilityTheory]","category":"page"},{"location":"#Base.MathConstants.π-Tuple{Vararg{Integer,N} where N}","page":"Index","title":"Base.MathConstants.π","text":"π(m::Integer..., algebraic::Bool = true)\n\nThe depairing function.  Takes in an integer and find its unique pair of integers such that those integers paired is exactly the function input:\n\npi(m) mapsto leftlangle m_0 m_1rightrangle\nmathbbN to mathbbN^2\n\nSetting boolean algebraic flag to false calls a brute force search method which is extremely slow for large n (see the n parameter below) but exists for completeness.  That is,\n\npi(m) = left(mu xleq mright)left(exists yleq mright)m=leftlangle xyrightrangle\npi_0left(leftlangle x_0x_1rightrangleright) = x_0\npi_1left(leftlangle x_0x_1rightrangleright) = x_1\n\nThis function also takes in a parameter n:\n\npi(m n) mapsto leftlangle m_1 ldots m_nrightrangle\nmathbbN to mathbbN^n\n\nThis function may also take in a third parameter k so that\n\npi(m n k) equiv pi_k^n mapsto leftlangle m_1 ldots m_nrightrangle mapsto m_kquadtextwhere 1leq kleq n\n\nnote: Note\nSee the note from documentation on pair_tuple.  This function may not do exactly what you expect.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.GoToProgramme","page":"Index","title":"Main.ComputabilityTheory.GoToProgramme","text":"struct GoToProgramme <: Programme\n\nThis struct has fields:\n\nP::Integer\nprogramme_length::Integer\ninstructions::Vector{<:Tuple}\nmax_line::Integer\n\n\n\nGoToProgramme(P::Integer)\n\nA goto programme can be coded by a single number!  This number in the struct is P.\n\n\n\nFor any d in mathbbN, the sequence code of a sequence (a_0a_1ldotsa_d-1) in mathbbN^d, denoted by a_0a_1ldotsa_d-1, is\n\nleftlangle d leftlangle a a_0a_1ldotsa_d-1rightranglerightrangle\n\nThen, P is a_0a_1ldotsa_d-1.  So, given P, π(P, 2, 0) is the number of lines of the programme, d; and π(P, 2, 1) is the programme itself.  Depairing that d times, we get a tuple of integers: the instructions of the programme (one integer codes one line in the programme). We define each line of the programme as being coded as follows:\n\nThe code for \"Rn = Rn + 1\" is leftlangle 0 nrightrangle;\nThe code for \"Rn = Rn - 1\" is leftlangle 1 nrightrangle;\nThe code for \"textttgoto  k\" is leftlangle 2 krightrangle;\nThe code for \"textttif  Rn = 0 texttt goto  k\" is leftlangle 3 leftlangle n krightranglerightrangle; and\nThe code for \"texttthalt\" is leftlangle 4 0rightrangle.\n\nIt should also be noted that the sequence code for some base cases is defined as follows:\n\nif d = 0, the sequence code  for the empty sequence is the number 0; and\nif d = 1, for a in mathbbN, the sequence code a for the sequence (a) of length 1, is leftlangle 1 arightrangle.\n\nThe constructor function for this struct will ensure that the given integer P is a valid goto programme.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Instruction","page":"Index","title":"Main.ComputabilityTheory.Instruction","text":"struct Instruction <: ProgrammeCompoment\n\nAn instruction is a command spanning a single line in a goto programme.\n\nThis struct has the fields:\n\nI::Integer\nfirst::Integer\nsecond::Integer\nthird::Union{Integer, Nothing}\ninstruction::Tuple\n\n\n\nInstruction(I::Integer)\n\nGiven an integer, this constructor function decodes the instruction.  An instruction can be one of five things, defined as follows:\n\nThe code for \"Rn = Rn + 1\" is leftlangle 0 nrightrangle;\nThe code for \"Rn = Rn - 1\" is leftlangle 1 nrightrangle;\nThe code for \"textttgoto  k\" is leftlangle 2 krightrangle;\nThe code for \"textttif  Rn = 0 texttt goto  k\" is leftlangle 3 leftlangle n krightranglerightrangle; and\nThe code for \"texttthalt\" is leftlangle 4 0rightrangle.\n\nInstruction(instruction::Tuple)\nInstruction(i::Integer, j::Integer...) = Instruction((i, j...))\n\nGiven a tuple or a list of values, the value of the instruction is the pair of all inputs.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.MachineState","page":"Index","title":"Main.ComputabilityTheory.MachineState","text":"mutable struct MachineState <: MachineComponent\n\nA snapshot of a state of a Turing machine.\n\nFields:\n\nstate::String: The name of the state of the Turing machine at the current machine state.\ntape::Dict{Int, String}: The current state of the tape of the machine.  The head will be atIntvalue, and the contents atString` value.\nheadpos::Int: The position of the head at the current state of the Turing Machine.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Move","page":"Index","title":"Main.ComputabilityTheory.Move","text":"@enum Move Left=1 Stay Right\n\nAn enumerated type Move.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.RegisterMachine","page":"Index","title":"Main.ComputabilityTheory.RegisterMachine","text":"mutable struct RegisterMachine <: Machine\n\nA register machine.  That is, a machine with finitely many registers, whose registers contain a natural number n ∈ ℕ ∪ {0}.\n\nFields:\n\ncontents::AbastractArray: The contents of the registers.\n\n\n\nRegisterMachine(contents::AbstractArray)\n\nA constructor function for the struct RegisterMachine.  Ensures the contents of the machine are indeed all natural numbers\n\n\n\nRegisterMachine(T::Union{Tuple, UnitRange})\nRegisterMachine(a::Integer, b::Integer...)\n\nConstructor functions for the struct RegisterMachine.  Your contents are allowed to be tuples, ranges, or a series of integers.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Rule","page":"Index","title":"Main.ComputabilityTheory.Rule","text":"struct Rule <: MachineComponent\n\nFields:\n\ninstate::String: The state name (String) where the rule starts.\noutstate::String: The state name (String) where the rule ends.\ns1::String: What the Turing machine will read.\ns2::String: What the Turing machine will write.\nmove::String: How the Turing machine will move (see Move).\n\nNote: instate and outstate are connected nodes in the Turing Machine.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Sequence","page":"Index","title":"Main.ComputabilityTheory.Sequence","text":"struct Sequence <: ProgrammeCompoment\n\nFor any d in mathbbN, the sequence code of a sequence (a_0a_1ldotsa_d-1) in mathbbN^d, denoted by a_0a_1ldotsa_d-1, is\n\nleftlangle d leftlangle a a_0a_1ldotsa_d-1rightranglerightrangle\n\nThe struct has the following fields:\n\nq::Integer\nseq_length::Integer\ninstructions::Tuple\n\nSequence(q::Integer)\nSequence(t::Tuple)\nSequence(i::Integer, j::Tuple)\nSequence(i::Integer, j::Integer...)\n\nThe constructor methods for this struct decode the given value(s) into the sequence.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.TMProgramme","page":"Index","title":"Main.ComputabilityTheory.TMProgramme","text":"struct TMProgramme <: TuringMachine\n\nFields:\n\ntitle::String: A descriptive name for your programme.\ninitial::String: The state name where the Turing machine begins.\nfinal::String: The state name where the Turing machine halts.\nblank::String: The symbol used to denote a blank cell.\nRules::Vector{Rule}`: A list of rules of the programme.\n\n\n\n\n\n","category":"type"},{"location":"#Base.show-Tuple{IO,MachineState}","page":"Index","title":"Base.show","text":"Base.show(io::IO, mstate::MachineState)\n\nPrints the current state of a Turing machine.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.:∸-Tuple{Number,Number}","page":"Index","title":"Main.ComputabilityTheory.:∸","text":"Truncated negation: an operator that acts like subtraction without going to negatives.\n\nThis can be written in the REPL as \\dotminus<tab>.\n\nExamples:\n\njulia> 6 ∸ 3\n3\n\njulia> 3 ∸ 1\n2\n\njulia> 10 ∸ 12\n0\n\njulia> 1 ∸ 2\n0\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.cℤ-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.cℤ","text":"cℤ(z::Integer)\ncℤ(z::Integer, w::Integer...)\n\nThis function uniquely maps an integer to a natural number.  The output is a BigInt.  This function can be written in the REPL by c\\bbZ<tab>.\n\nz mapsto cmathbbZ(z)\nz w ldots mapsto cmathbbZ(z) cmathbbZ(w) ldots\nmathbbZ to mathbbN\n\n\n\ncℤ(zs::AbstractArray{<:Integer})\n\nGiven an array of integers, cℤ will convert every element of the array into natrual numbers.\n\n\n\ncℤ(r::NTuple{N, Integer})\n\nGiven a tuple, cℤ will convert ever element of the tuple into natural numbers, and pair the result:\n\nleft(z wright) mapsto cmathbbZleft(leftlangle z wrightrangleright)\nmathbbZ^2 to mathbbN\n\nleft(z_1 ldots z_nright) mapsto cmathbbZleft(leftlangle z_1rightrangleright) ldots cmathbbZleft(leftlangle z_nrightrangleright)\nmathbbZ^n to mathbbN\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.cℤ⁻¹-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.cℤ⁻¹","text":"cℤ⁻¹(n::Integer)\n\nThe inverse of cℤ⁻¹.  Uniquely maps natural numbers to integers.  This function can be written in the REPL by c\\bbZ<tab>\\^1<tab>.\n\n\n\ncℤ⁻¹(zs::AbstractArray{<:Integer})\n\nGiven an array of integers, cℤ⁻¹ will convert every element of the array into integers.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.decrement-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.decrement","text":"decrement(n::Integer)\n\nConstructs an Instruction object for decrementing the ntextsuperscriptth register.\n\nThe code for \"Rn = Rn - 1\" is leftlangle 1 nrightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.goto-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.goto","text":"goto(n::Integer)\n\nConstructs an Instruction object for going to line k.\n\nThe code for \"textttgoto  k\" is leftlangle 2 krightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.halt-Tuple{}","page":"Index","title":"Main.ComputabilityTheory.halt","text":"halt()\n\nConstructs an Instruction object for the final line of all goto programmes: halt.\n\nThe code for \"texttthalt\" is leftlangle 4 0rightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.ifzero_goto-Tuple{Tuple{Integer,Integer}}","page":"Index","title":"Main.ComputabilityTheory.ifzero_goto","text":"ifzero_goto(t::NTuple{2, Integer})\nifzero_goto(n::Integer, k::Integer)\n\nConstructs an Instruction object for going to line k if and only  if the ntextsuperscriptth register is zero.\n\nThe code for \"textttif  Rn = 0 texttt goto  k\" is leftlangle 3 leftlangle n krightranglerightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.increment-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.increment","text":"increment(n::Integer)\n\nConstructs an Instruction object for incrementing the ntextsuperscriptth register.\n\nThe code for \"Rn = Rn + 1\" is leftlangle 0 nrightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.pair_tuple-Tuple{Integer,Integer}","page":"Index","title":"Main.ComputabilityTheory.pair_tuple","text":"pair_tuple(x::Integer, y::Integer)\npair_tuple(x::Integer, y::Integer, z::Integer...)\npair_tuple(t::Tuple)\n\nThe pairing function is a function that uniquely maps any number of integer inputs to a single integer:\n\nleft(k_1k_2right) mapsto frac12left(k_1+k_2right)left(k_1+k_2+1right)+k_1\nmathbbN^2 to mathbbN\n\nThis concept can also be generalised to take integers x_0 to x_n-1 so that\n\n(x_0 x_1 ldots x_n - 1) mapsto leftlangleleftlangle x_0 ldots x_n - 2rightrangle x_n - 1rightrangle\nmathbbN^n to mathbbN\n\nand returns their \"pair\".\n\nAs this maps every combination of integers to a single output, this number gets massive very fast.  As such, pair_tuple will return a BigInt.\n\nTo depair the tuple, see pi.\n\nFor more information, see https://en.m.wikipedia.org/wiki/Pairing_function.\n\nnote: Note\nThere are two variations to this process which will change the output:As per the visualisation in the link above, the first number given is found along the x axis, and the second along the y axis.  In this implementation, it is the other way around.  This can easily by modified, however, by adding k_1 at the end instead of k_2.\nThe other variation is which direction of nesting we decide on for more than 2 inputs.  The alternative (which we do not use in this implementation) is\nleft(x_0 x_1 ldots x_n - 1right) mapsto leftlangle x_0 leftlangle x_1 ldots x_n - 1rightranglerightrangle\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.run_goto_programme-Tuple{GoToProgramme,RegisterMachine}","page":"Index","title":"Main.ComputabilityTheory.run_goto_programme","text":"run_goto_programme(P::GoToProgramme, R::RegisterMachine) -> RegisterMachine.contents\nrun_goto_programme(P::GoToProgramme, T::Tuple) -> RegisterMachine.contents\nrun_goto_programme(P::Integer, T::Tuple) -> RegisterMachine.contents\nrun_goto_programme(P::Integer, R::RegisterMachine) -> RegisterMachine.contents\n\nTakes in a coded programme P (for coding a programme, see notes), and runs the programme using register machine R.  It a tuple is given, will convert to a register machine whose contents is the tuple.  If an integer is given, will convert to a goto programme.\n\nNotes: There are five possible instructions for a GoTo programme:\n\nIncrement Rᵢ  ⟵ pair_tuple(0, i)\nDecrement Rᵢ  ⟵ pair_tuple(1, i)\nGoto line k  ⟵ pair_tuple(2, k)\nIf Rᵢ is zero, goto line k  ⟵ pair_tuple(3, (i, k))\nHalt  ⟵ pair_tuple(4, 0)\n\nThen, the programme P, consisting of instructions I₁, I₂, ..., Iᵢ, is coded by\n\npair_tuple(i, pair_tuple(I₁, I₂, ..., Iᵢ))\n\nFor utilities regarding these instructions, see pair_tuple, Sequence, Instruction, increment, decrement, goto, ifzero_goto, halt, and GoToProgramme.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.run_turing_machine-Tuple{Any,Any,Any}","page":"Index","title":"Main.ComputabilityTheory.run_turing_machine","text":"run_turing_machine(TMProgramme, tape, verbose)\n\nRun a specified Turing programme on a specified tape.  verbose is a boolean.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.show_programme-Tuple{IO,GoToProgramme}","page":"Index","title":"Main.ComputabilityTheory.show_programme","text":"show_programme(io::IO, P::GoToProgramme)\nshow_programme(P::GoToProgramme)\nshow_programme(P::Integer)\n\nGiven a goto programme, this function will decode it into its constituent components.  It will default to stdout.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"}]
}
