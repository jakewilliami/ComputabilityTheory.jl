var documenterSearchIndex = {"docs":
[{"location":"#ComputabilityTheory.jl-Documentation","page":"Index","title":"ComputabilityTheory.jl Documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = ComputabilityTheory\nDocTestSetup = quote\n    using ComputabilityTheory\nend","category":"page"},{"location":"#Adding-ComputabilityTheory.jl","page":"Index","title":"Adding ComputabilityTheory.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"ComputabilityTheory\")","category":"page"},{"location":"#Documentation","page":"Index","title":"Documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [ComputabilityTheory]","category":"page"},{"location":"#Base.MathConstants.π-Tuple{Vararg{Integer}}","page":"Index","title":"Base.MathConstants.π","text":"π(m::Integer..., algebraic::Bool = true)\n\nThe depairing function.  Takes in an integer and find its unique pair of integers such that those integers paired is exactly the function input:\n\npi(m) mapsto leftlangle m_0 m_1rightrangle\nmathbbN to mathbbN^2\n\nSetting boolean algebraic flag to false calls a brute force search method which is extremely slow for large n (see the n parameter below) but exists for completeness.  That is,\n\npi(m) = left(mu xleq mright)left(exists yleq mright)m=leftlangle xyrightrangle\npi_0left(leftlangle x_0x_1rightrangleright) = x_0\npi_1left(leftlangle x_0x_1rightrangleright) = x_1\n\nThis function also takes in a parameter n:\n\npi(m n) mapsto leftlangle m_1 ldots m_nrightrangle\nmathbbN to mathbbN^n\n\nThis function may also take in a third parameter k so that\n\npi(m n k) equiv pi_k^n mapsto leftlangle m_1 ldots m_nrightrangle mapsto m_kquadtextwhere 1leq kleq n\n\nnote: Note\nSee the note from documentation on pair_tuple.  This function may not do exactly what you expect.\n\n\n\nExamples\n\njulia> π(83, algebraic = false) # code a natural number into a 2-tuple\n(5, 7)\n\njulia> π(83, 2, algebraic = true) # use algebraic method of depairing rather than search (much faster)\n(5, 7)\n\njulia> π(83, 2, 1, algebraic = false) # code a natural number into a 2-tuple and get the the number in the tuple indexed by 1 (index starting from zero)\n7\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.GoToProgramme","page":"Index","title":"Main.ComputabilityTheory.GoToProgramme","text":"struct GoToProgramme <: Programme\n\nThis struct has fields:\n\nP::Integer\nprogramme_length::Integer\ninstructions::Vector{<:Tuple}\nmax_line::Integer\n\n\n\nGoToProgramme(P::Integer)\nGoToProgramme(S::Sequence)\n\nA goto programme can be coded by a single number!  This number in the struct is P.\n\n\n\nFor any d in mathbbN, the sequence code of a sequence (a_0a_1ldotsa_d-1) in mathbbN^d, denoted by a_0a_1ldotsa_d-1, is\n\nleftlangle d leftlangle a a_0a_1ldotsa_d-1rightranglerightrangle\n\nThen, P is a_0a_1ldotsa_d-1.  So, given P, π(P, 2, 0) is the number of lines of the programme, d; and π(P, 2, 1) is the programme itself.  Depairing that d times, we get a tuple of integers: the instructions of the programme (one integer codes one line in the programme). We define each line of the programme as being coded as follows:\n\nThe code for \"Rn = Rn + 1\" is leftlangle 0 nrightrangle;\nThe code for \"Rn = Rn - 1\" is leftlangle 1 nrightrangle;\nThe code for \"textttgoto  k\" is leftlangle 2 krightrangle;\nThe code for \"textttif  Rn = 0 texttt goto  k\" is leftlangle 3 leftlangle n krightranglerightrangle; and\nThe code for \"texttthalt\" is leftlangle 4 0rightrangle.\n\nIt should also be noted that the sequence code for some base cases is defined as follows:\n\nif d = 0, the sequence code  for the empty sequence is the number 0; and\nif d = 1, for a in mathbbN, the sequence code a for the sequence (a) of length 1, is leftlangle 1 arightrangle.\n\nThe constructor function for this struct will ensure that the given integer P is a valid goto programme.\n\n\n\nExamples\n\njulia> GoToProgramme(121).length\n1\n\njulia> GoToProgramme(121).instructions\n1-element Array{Tuple{BigInt,BigInt},1}:\n (4, 0)\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Instruction","page":"Index","title":"Main.ComputabilityTheory.Instruction","text":"struct Instruction <: ProgrammeCompoment\n\nAn instruction is a command spanning a single line in a goto programme.\n\nThis struct has the fields:\n\nI::Integer\nfirst::Integer\nsecond::Integer\nthird::Union{Integer, Nothing}\ninstruction::Tuple\n\n\n\nInstruction(I::Integer)\n\nGiven an integer, this constructor function decodes the instruction.  An instruction can be one of five things, defined as follows:\n\nThe code for \"Rn = Rn + 1\" is leftlangle 0 nrightrangle;\nThe code for \"Rn = Rn - 1\" is leftlangle 1 nrightrangle;\nThe code for \"textttgoto  k\" is leftlangle 2 krightrangle;\nThe code for \"textttif  Rn = 0 texttt goto  k\" is leftlangle 3 leftlangle n krightranglerightrangle; and\nThe code for \"texttthalt\" is leftlangle 4 0rightrangle.\n\nInstruction(instruction::Tuple)\nInstruction(i::Integer, j::Integer...) = Instruction((i, j...))\n\nGiven a tuple or a list of values, the value of the instruction is the pair of all inputs.\n\n\n\nExamples\n\njulia> Instruction((3, (1, 2))).I\n58\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.MachineState","page":"Index","title":"Main.ComputabilityTheory.MachineState","text":"mutable struct MachineState <: MachineComponent\n\nA snapshot of a state of a Turing machine.\n\nFields:\n\nstate::String: The name of the state of the Turing machine at the current machine state.\ntape::Dict{Int, String}: The current state of the tape of the machine.  The head will be atIntvalue, and the contents atString` value.\nheadpos::Int: The position of the head at the current state of the Turing Machine.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Move","page":"Index","title":"Main.ComputabilityTheory.Move","text":"@enum Move Left=1 Stay Right\n\nAn enumerated type Move.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.RegisterMachine","page":"Index","title":"Main.ComputabilityTheory.RegisterMachine","text":"mutable struct RegisterMachine <: Machine\n\nA register machine.  That is, a machine with finitely many registers, whose registers contain a natural number n ∈ ℕ ∪ {0}.\n\nFields:\n\ncontents::AbastractArray: The contents of the registers.\n\n\n\nRegisterMachine(contents::AbstractArray)\n\nA constructor function for the struct RegisterMachine.  Ensures the contents of the machine are indeed all natural numbers\n\n\n\nRegisterMachine(T::Union{Tuple, UnitRange})\nRegisterMachine(a::Integer, b::Integer...)\n\nConstructor functions for the struct RegisterMachine.  Your contents are allowed to be tuples, ranges, or a series of integers.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Rule","page":"Index","title":"Main.ComputabilityTheory.Rule","text":"struct Rule <: MachineComponent\n\nFields:\n\ninstate::String: The state name (String) where the rule starts.\noutstate::String: The state name (String) where the rule ends.\ns1::String: What the Turing machine will read.\ns2::String: What the Turing machine will write.\nmove::String: How the Turing machine will move (see Move).\n\nNote: instate and outstate are connected nodes in the Turing Machine.\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.Sequence","page":"Index","title":"Main.ComputabilityTheory.Sequence","text":"struct Sequence <: ProgrammeCompoment\n\nFor any d in mathbbN, the sequence code of a sequence (a_0a_1ldotsa_d-1) in mathbbN^d, denoted by a_0a_1ldotsa_d-1, is\n\nleftlangle d leftlangle a a_0a_1ldotsa_d-1rightranglerightrangle\n\nThe struct has the following fields:\n\nq::Integer\nseq_length::Integer\ninstructions::Tuple\n\nSequence(q::Integer)\nSequence(t::Tuple)\nSequence(i::Integer, j::Tuple)\nSequence(i::Integer, j::Integer...)\n\nThe constructor methods for this struct decode the given value(s) into the sequence.\n\n\n\nExamples\n\njulia> Sequence(972292871301644916468488152875266508938968846389326007980307063346008398713128885682044504108288931767348821063618087715644933567266540511345568504718733339523678538338052787779884557674350959673597803113281693069940562881722205193604550737455583875504348606989700013337656597740101535).instructions\n(328, 4, 531, 4, 5, 0, 14)\n\n\n\n\n\n","category":"type"},{"location":"#Main.ComputabilityTheory.TMProgramme","page":"Index","title":"Main.ComputabilityTheory.TMProgramme","text":"struct TMProgramme <: TuringMachine\n\nFields:\n\ntitle::String: A descriptive name for your programme.\ninitial::String: The state name where the Turing machine begins.\nfinal::String: The state name where the Turing machine halts.\nblank::String: The symbol used to denote a blank cell.\nRules::Vector{Rule}`: A list of rules of the programme.\n\n\n\n\n\n","category":"type"},{"location":"#Base.rand-Tuple{Type{GoToProgramme}, Integer}","page":"Index","title":"Base.rand","text":"rand(::Type{GoToProgramme}, d::Integer; upper_bound::Integer = 200)\n\nFinds a random go-to programme.\n\nrand takes in the type, GoToProgramme, a number of lines of the programme, d, and an upper bound for the main instructions (coded; not including the halt instruction) which defaults to 200.  (Recall how we code instructions, using pair_tuple, so numbers between 1 and 200 will produce reasonably small codes)\n\nnote: Note\nThis may be slow.  Depending on how large your upper bound is, it may take a while to find a valid code.\n\n\n\nExamples\n\njulia> show_programme(rand(GoToProgramme, 3, upper_bound = 200)) # a reasonably small random programme with 3 lines\n0    R3 := R3 + 1\n1    if R0 = 0 goto 1\n2    halt\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, MachineState}","page":"Index","title":"Base.show","text":"Base.show(io::IO, mstate::MachineState)\n\nPrints the current state of a Turing machine.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.:∸-Tuple{Number, Number}","page":"Index","title":"Main.ComputabilityTheory.:∸","text":"Truncated negation: an operator that acts like subtraction without going to negatives.\n\nThis can be written in the REPL as \\dotminus<tab>.\n\nExamples:\n\njulia> 6 ∸ 3\n3\n\njulia> 3 ∸ 1\n2\n\njulia> 10 ∸ 12\n0\n\njulia> 1 ∸ 2\n0\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.cℤ-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.cℤ","text":"cℤ(z::Integer)\ncℤ(z::Integer, w::Integer...)\n\nThis function uniquely maps an integer to a natural number.  The output is a BigInt.  This function can be written in the REPL by c\\bbZ<tab>.\n\nz mapsto cmathbbZ(z)\nz w ldots mapsto cmathbbZ(z) cmathbbZ(w) ldots\nmathbbZ to mathbbN\n\n\n\ncℤ(zs::AbstractArray{<:Integer})\n\nGiven an array of integers, cℤ will convert every element of the array into natrual numbers.\n\n\n\ncℤ(r::NTuple{N, Integer})\n\nGiven a tuple, cℤ will convert ever element of the tuple into natural numbers, and pair the result:\n\nleft(z wright) mapsto cmathbbZleft(leftlangle z wrightrangleright)\nmathbbZ^2 to mathbbN\n\nleft(z_1 ldots z_nright) mapsto cmathbbZleft(leftlangle z_1rightrangleright) ldots cmathbbZleft(leftlangle z_nrightrangleright)\nmathbbZ^n to mathbbN\n\n\n\nExamples\n\njulia> cℤ(-10) # code integer as a natural number\n19\n\njulia> cℤ((-1,2)) # cℤ pairs the code of each\n16\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.cℤ⁻¹-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.cℤ⁻¹","text":"cℤ⁻¹(n::Integer)\n\nThe inverse of cℤ⁻¹.  Uniquely maps natural numbers to integers.  This function can be written in the REPL by c\\bbZ<tab>\\^1<tab>.\n\n\n\ncℤ⁻¹(zs::AbstractArray{<:Integer})\n\nGiven an array of integers, cℤ⁻¹ will convert every element of the array into integers.\n\n\n\nExamples\n\njulia> cℤ⁻¹(19)\n-10\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.decrement-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.decrement","text":"decrement(n::Integer)\n\nConstructs an Instruction object for decrementing the ntextsuperscriptth register.\n\nThe code for \"Rn = Rn - 1\" is leftlangle 1 nrightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.goto-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.goto","text":"goto(n::Integer)\n\nConstructs an Instruction object for going to line k.\n\nThe code for \"textttgoto  k\" is leftlangle 2 krightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.halt-Tuple{}","page":"Index","title":"Main.ComputabilityTheory.halt","text":"halt()\n\nConstructs an Instruction object for the final line of all goto programmes: halt.\n\nThe code for \"texttthalt\" is leftlangle 4 0rightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.ifzero_goto-Tuple{Tuple{Integer, Integer}}","page":"Index","title":"Main.ComputabilityTheory.ifzero_goto","text":"ifzero_goto(t::NTuple{2, Integer})\nifzero_goto(n::Integer, k::Integer)\n\nConstructs an Instruction object for going to line k if and only  if the ntextsuperscriptth register is zero.\n\nThe code for \"textttif  Rn = 0 texttt goto  k\" is leftlangle 3 leftlangle n krightranglerightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.increment-Tuple{Integer}","page":"Index","title":"Main.ComputabilityTheory.increment","text":"increment(n::Integer)\n\nConstructs an Instruction object for incrementing the ntextsuperscriptth register.\n\nThe code for \"Rn = Rn + 1\" is leftlangle 0 nrightrangle.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.pair_tuple-Tuple{Integer, Integer}","page":"Index","title":"Main.ComputabilityTheory.pair_tuple","text":"pair_tuple(x::Integer, y::Integer)\npair_tuple(x::Integer, y::Integer, z::Integer...)\npair_tuple(t::Tuple)\n\nThe pairing function is a function that uniquely maps any number of integer inputs to a single integer:\n\nleft(k_1k_2right) mapsto frac12left(k_1+k_2right)left(k_1+k_2+1right)+k_1\nmathbbN^2 to mathbbN\n\nThis concept can also be generalised to take integers x_0 to x_n-1 so that\n\n(x_0 x_1 ldots x_n - 1) mapsto leftlangleleftlangle x_0 ldots x_n - 2rightrangle x_n - 1rightrangle\nmathbbN^n to mathbbN\n\nand returns their \"pair\".\n\nAs this maps every combination of integers to a single output, this number gets massive very fast.  As such, pair_tuple will return a BigInt.\n\nTo depair the tuple, see pi.\n\nFor more information, see https://en.m.wikipedia.org/wiki/Pairing_function.\n\nnote: Note\nThere are two variations to this process which will change the output:As per the visualisation in the link above, the first number given is found along the x axis, and the second along the y axis.  In this implementation, it is the other way around.  This can easily by modified, however, by adding k_1 at the end instead of k_2.\nThe other variation is which direction of nesting we decide on for more than 2 inputs.  The alternative (which we do not use in this implementation) is\nleft(x_0 x_1 ldots x_n - 1right) mapsto leftlangle x_0 leftlangle x_1 ldots x_n - 1rightranglerightrangle\n\n\n\nExamples\n\njulia> pair_tuple(5,7) # code pair of natural numbers as a natural number\n83\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.rand_unsafe-Tuple{Type{GoToProgramme}, Integer}","page":"Index","title":"Main.ComputabilityTheory.rand_unsafe","text":"rand_unsafe(::Type{GoToProgramme}, d::Integer; upper_bound::Integer = 200)\n\nFinds a random go-to programme.\n\nrand_unsafe takes in the type, GoToProgramme, a number of lines of the programme, d, and an upper bound for the main instructions (coded; not including the halt instruction) which defaults to 200.  (Recall how we code instructions, using pair_tuple, so numbers between 1 and 200 will produce reasonably small codes)\n\nnote: Note\n*This sometimes fails, as not every random number will deconstruct into a nice go-to programme.  Programmatically, I have done as much as I can to try to avoid this failing.  It is more likely to fail as you increase the upper bound.  To avoid this, try using rand, though be warned it might be a little slower as it will keep trying till it finds something.\n\n\n\nExamples\n\njulia> show_programme(ComputabilityTheory.rand_unsafe(GoToProgramme, 3, upper_bound = 200)) # a reasonably small random programme with 3 lines\n0    R3 := R3 + 1\n1    if R0 = 0 goto 1\n2    halt\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.run_goto_programme-Tuple{GoToProgramme, RegisterMachine}","page":"Index","title":"Main.ComputabilityTheory.run_goto_programme","text":"run_goto_programme(P::GoToProgramme, R::RegisterMachine) -> RegisterMachine.contents\nrun_goto_programme(P::GoToProgramme, T::Tuple) -> RegisterMachine.contents\nrun_goto_programme(P::Integer, T::Tuple) -> RegisterMachine.contents\nrun_goto_programme(P::Integer, R::RegisterMachine) -> RegisterMachine.contents\n\nTakes in a coded programme P (for coding a programme, see notes), and runs the programme using register machine R.  It a tuple is given, will convert to a register machine whose contents is the tuple.  If an integer is given, will convert to a goto programme.\n\nNotes: There are five possible instructions for a GoTo programme:\n\nIncrement Rᵢ  ⟵ pair_tuple(0, i)\nDecrement Rᵢ  ⟵ pair_tuple(1, i)\nGoto line k  ⟵ pair_tuple(2, k)\nIf Rᵢ is zero, goto line k  ⟵ pair_tuple(3, (i, k))\nHalt  ⟵ pair_tuple(4, 0)\n\nThen, the programme P, consisting of instructions I₁, I₂, ..., Iᵢ, is coded by\n\npair_tuple(i, pair_tuple(I₁, I₂, ..., Iᵢ))\n\nFor utilities regarding these instructions, see pair_tuple, Sequence, Instruction, increment, decrement, goto, ifzero_goto, halt, and GoToProgramme.\n\n\n\nExamples\n\njulia> run_goto_programme(363183787614755732766753446033240)\n(1, 0)\n\njulia> run_goto_programme(363183787614755732766753446033240, Register(0, 0, 0 ,0))\n(1, 0, 0, 0)\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.run_turing_machine-Tuple{Any, Any, Any}","page":"Index","title":"Main.ComputabilityTheory.run_turing_machine","text":"run_turing_machine(TMProgramme, tape, verbose)\n\nRun a specified Turing programme on a specified tape.  verbose is a boolean.\n\n\n\n\n\n","category":"method"},{"location":"#Main.ComputabilityTheory.show_programme-Tuple{IO, GoToProgramme}","page":"Index","title":"Main.ComputabilityTheory.show_programme","text":"show_programme(io::IO, P::GoToProgramme)\nshow_programme(P::GoToProgramme)\nshow_programme(P::Integer)\n\nGiven a goto programme, this function will decode it into its constituent components.  It will default to stdout.\n\n\n\nExamples\n\njulia> show_programme(121)\n0    halt\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"}]
}
