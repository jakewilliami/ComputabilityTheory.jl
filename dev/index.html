<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · ComputabilityTheory Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ComputabilityTheory Documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Adding-ComputabilityTheory.jl"><span>Adding ComputabilityTheory.jl</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ComputabilityTheory.jl-Documentation"><a class="docs-heading-anchor" href="#ComputabilityTheory.jl-Documentation">ComputabilityTheory.jl Documentation</a><a id="ComputabilityTheory.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#ComputabilityTheory.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="#ComputabilityTheory.jl-Documentation">ComputabilityTheory.jl Documentation</a></li><li class="no-marker"><ul><li><a href="#Adding-ComputabilityTheory.jl">Adding ComputabilityTheory.jl</a></li><li><a href="#Documentation">Documentation</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Adding-ComputabilityTheory.jl"><a class="docs-heading-anchor" href="#Adding-ComputabilityTheory.jl">Adding ComputabilityTheory.jl</a><a id="Adding-ComputabilityTheory.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-ComputabilityTheory.jl" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Pkg</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.add(&quot;ComputabilityTheory&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">    Updating registry at `~/.julia/registries/General.toml`
   Resolving package versions...
   Installed ComputabilityTheory ─ v0.1.1
    Updating `~/work/ComputabilityTheory.jl/ComputabilityTheory.jl/docs/Project.toml`
  [1aac4ff9] ~ ComputabilityTheory v0.1.2 `~/work/ComputabilityTheory.jl/ComputabilityTheory.jl` ⇒ v0.1.1
    Updating `~/work/ComputabilityTheory.jl/ComputabilityTheory.jl/docs/Manifest.toml`
  [1aac4ff9] ~ ComputabilityTheory v0.1.2 `~/work/ComputabilityTheory.jl/ComputabilityTheory.jl` ⇒ v0.1.1
Precompiling project...
<span class="sgr32">  ✓ </span>ComputabilityTheory
  1 dependency successfully precompiled in 1 seconds. 7 already precompiled.</code></pre><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.MathConstants.π-Tuple{Vararg{Integer}}" href="#Base.MathConstants.π-Tuple{Vararg{Integer}}"><code>Base.MathConstants.π</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">π(m::Integer..., algebraic::Bool = true)</code></pre><p>The depairing function.  Takes in an integer and find its unique pair of integers such that those integers paired is exactly the function input:</p><p class="math-container">\[\pi(m) \mapsto \left\langle m_0, m_1\right\rangle\\
\mathbb{N} \to \mathbb{N}^2\]</p><p>Setting boolean <code>algebraic</code> flag to <code>false</code> calls a brute force search method which is extremely slow for large <span>$n$</span> (see the <code>n</code> parameter below) but exists for completeness.  That is,</p><p class="math-container">\[\pi(m) := \left(\mu x\leq m\right)\left(\exists y\leq m\right)m=\left\langle x,y\right\rangle\\
\pi_0\left(\left\langle x_0,x_1\right\rangle\right) = x_0\\
\pi_1\left(\left\langle x_0,x_1\right\rangle\right) = x_1\]</p><p>This function also takes in a parameter <span>$n$</span>:</p><p class="math-container">\[\pi(m, n) \mapsto \left\langle m_1, \ldots, m_n\right\rangle\\
\mathbb{N} \to \mathbb{N}^n\]</p><p>This function may also take in a third parameter <span>$k$</span> so that</p><p class="math-container">\[\pi(m, n, k) \equiv \pi_k^n \mapsto \left\langle m_1, \ldots, m_n\right\rangle \mapsto m_k\quad\text{where }1\leq k\leq n\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>See the note from documentation on <code>pair_tuple</code>.  This function may not do exactly what you expect.</p></div></div><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; π(83, algebraic = false) # code a natural number into a 2-tuple
(5, 7)

julia&gt; π(83, 2, algebraic = true) # use algebraic method of depairing rather than search (much faster)
(5, 7)

julia&gt; π(83, 2, 1, algebraic = false) # code a natural number into a 2-tuple and get the the number in the tuple indexed by 1 (index starting from zero)
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/coding.jl#L164-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.GoToProgramme" href="#Main.ComputabilityTheory.GoToProgramme"><code>Main.ComputabilityTheory.GoToProgramme</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GoToProgramme &lt;: Programme</code></pre><p>This struct has fields:</p><ul><li><code>P::Integer</code></li><li><code>programme_length::Integer</code></li><li><code>instructions::Vector{&lt;:Tuple}</code></li><li><code>max_line::Integer</code></li></ul><hr/><pre><code class="language-julia hljs">GoToProgramme(P::Integer)
GoToProgramme(S::Sequence)</code></pre><p>A goto programme can be coded by a single number!  This number in the struct is <code>P</code>.</p><hr/><p>For any <span>$d \in \mathbb{N}$</span>, the sequence code of a sequence <span>$(a_0,a_1,\ldots,a_{d-1}) \in \mathbb{N}^d$</span>, denoted by <span>$[a_0,a_1,\ldots,a_{d-1}]$</span>, is</p><p class="math-container">\[\left\langle d, \left\langle a a_0,a_1,\ldots,a_{d-1}\right\rangle\right\rangle\]</p><p>Then, P is <span>$[a_0,a_1,\ldots,a_{d-1}]$</span>.  So, given <span>$P$</span>, <code>π(P, 2, 0)</code> is the number of lines of the programme, d; and <code>π(P, 2, 1)</code> is the programme itself.  Depairing that <span>$d$</span> times, we get a tuple of integers: the instructions of the programme (one integer codes one line in the programme). We define each line of the programme as being coded as follows:</p><ul><li>The code for &quot;<span>$Rn := Rn + 1$</span>&quot; is <span>$\left\langle 0, n\right\rangle$</span>;</li><li>The code for &quot;<span>$Rn := Rn - 1$</span>&quot; is <span>$\left\langle 1, n\right\rangle$</span>;</li><li>The code for &quot;<span>$\texttt{goto } k$</span>&quot; is <span>$\left\langle 2, k\right\rangle$</span>;</li><li>The code for &quot;<span>$\texttt{if } Rn = 0 \texttt{ goto } k$</span>&quot; is <span>$\left\langle 3, \left\langle n, k\right\rangle\right\rangle$</span>; and</li><li>The code for &quot;<span>$\texttt{halt}$</span>&quot; is <span>$\left\langle 4, 0\right\rangle$</span>.</li></ul><p>It should also be noted that the sequence code for some base cases is defined as follows:</p><ul><li>if <span>$d = 0$</span>, the sequence code <span>$[]$</span> for the empty sequence is the number 0; and</li><li>if <span>$d = 1$</span>, for <span>$a \in \mathbb{N}$</span>, the sequence code <span>$[a]$</span> for the sequence <span>$(a)$</span> of length 1, is <span>$\left\langle 1, a\right\rangle$</span>.</li></ul><p>The constructor function for this struct will ensure that the given integer <code>P</code> is a valid goto programme.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; GoToProgramme(121).length
1

julia&gt; GoToProgramme(121).instructions
1-element Array{Tuple{BigInt,BigInt},1}:
 (4, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L222-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.Instruction" href="#Main.ComputabilityTheory.Instruction"><code>Main.ComputabilityTheory.Instruction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Instruction &lt;: ProgrammeCompoment</code></pre><p>An instruction is a command spanning a single line in a goto programme.</p><p>This struct has the fields:</p><ul><li><code>I::Integer</code></li><li><code>first::Integer</code></li><li><code>second::Integer</code></li><li><code>third::Union{Integer, Nothing}</code></li><li><code>instruction::Tuple</code></li></ul><hr/><pre><code class="language-julia hljs">Instruction(I::Integer)</code></pre><p>Given an integer, this constructor function decodes the instruction.  An instruction can be one of five things, defined as follows:</p><ul><li>The code for &quot;<span>$Rn := Rn + 1$</span>&quot; is <span>$\left\langle 0, n\right\rangle$</span>;</li><li>The code for &quot;<span>$Rn := Rn - 1$</span>&quot; is <span>$\left\langle 1, n\right\rangle$</span>;</li><li>The code for &quot;<span>$\texttt{goto } k$</span>&quot; is <span>$\left\langle 2, k\right\rangle$</span>;</li><li>The code for &quot;<span>$\texttt{if } Rn = 0 \texttt{ goto } k$</span>&quot; is <span>$\left\langle 3, \left\langle n, k\right\rangle\right\rangle$</span>; and</li><li>The code for &quot;<span>$\texttt{halt}$</span>&quot; is <span>$\left\langle 4, 0\right\rangle$</span>.</li></ul><pre><code class="language-julia hljs">Instruction(instruction::Tuple)
Instruction(i::Integer, j::Integer...) = Instruction((i, j...))</code></pre><p>Given a tuple or a list of values, the value of the instruction is the pair of all inputs.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Instruction((3, (1, 2))).I
58</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L7-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.MachineState" href="#Main.ComputabilityTheory.MachineState"><code>Main.ComputabilityTheory.MachineState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MachineState &lt;: MachineComponent</code></pre><p>A snapshot of a state of a Turing machine.</p><p>Fields:</p><ul><li><code>state::String</code>: The name of the state of the Turing machine at the current machine state.</li><li><code>tape::Dict{Int, String}</code><code>: The current state of the tape of the machine.  The head will be at</code>Int<code>value, and the contents at</code>String` value.</li><li><code>headpos::Int</code>: The position of the head at the current state of the Turing Machine.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.Move" href="#Main.ComputabilityTheory.Move"><code>Main.ComputabilityTheory.Move</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum Move Left=1 Stay Right</code></pre><p>An enumerated type <code>Move</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.RegisterMachine" href="#Main.ComputabilityTheory.RegisterMachine"><code>Main.ComputabilityTheory.RegisterMachine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct RegisterMachine &lt;: Machine</code></pre><p>A register machine.  That is, a machine with finitely many registers, whose registers contain a natural number n ∈ ℕ ∪ {0}.</p><p>Fields:</p><ul><li><code>contents::AbastractArray</code>: The contents of the registers.</li></ul><hr/><pre><code class="language-julia hljs">RegisterMachine(contents::AbstractArray)</code></pre><p>A constructor function for the <code>struct</code> <code>RegisterMachine</code>.  Ensures the contents of the machine are indeed all natural numbers</p><hr/><pre><code class="language-julia hljs">RegisterMachine(T::Union{Tuple, UnitRange})
RegisterMachine(a::Integer, b::Integer...)</code></pre><p>Constructor functions for the <code>struct</code> <code>RegisterMachine</code>.  Your contents are allowed to be tuples, ranges, or a series of integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L136-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.Rule" href="#Main.ComputabilityTheory.Rule"><code>Main.ComputabilityTheory.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Rule &lt;: MachineComponent</code></pre><p>Fields:</p><ul><li><code>instate::String</code>: The state name (<code>String</code>) where the rule starts.</li><li><code>outstate::String</code>: The state name (<code>String</code>) where the rule ends.</li><li><code>s1::String</code>: What the Turing machine will read.</li><li><code>s2::String</code>: What the Turing machine will write.</li><li><code>move::String</code>: How the Turing machine will move (see <code>Move</code>).</li></ul><p>Note: <code>instate</code> and <code>outstate</code> are connected nodes in the Turing Machine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.Sequence" href="#Main.ComputabilityTheory.Sequence"><code>Main.ComputabilityTheory.Sequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Sequence &lt;: ProgrammeCompoment</code></pre><p>For any <span>$d \in \mathbb{N}$</span>, the sequence code of a sequence <span>$(a_0,a_1,\ldots,a_{d-1}) \in \mathbb{N}^d$</span>, denoted by <span>$[a_0,a_1,\ldots,a_{d-1}]$</span>, is</p><p class="math-container">\[q = \left\langle d, \left\langle a a_0,a_1,\ldots,a_{d-1}\right\rangle\right\rangle\]</p><p>The struct has the following fields:</p><ul><li><code>q::Integer</code></li><li><code>seq_length::Integer</code></li><li><code>instructions::Tuple</code></li></ul><pre><code class="language-julia hljs">Sequence(q::Integer) # instructions_coded
Sequence(t::Tuple) # (seq_length, instructions_coded)
Sequence(seq_length::Integer, j::Tuple)
Sequence(i::Integer, j::Integer...)
Sequence(i::Instruction...)</code></pre><p>The constructor methods for this struct decode the given value(s) into the sequence.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Sequence(972292871301644916468488152875266508938968846389326007980307063346008398713128885682044504108288931767348821063618087715644933567266540511345568504718733339523678538338052787779884557674350959673597803113281693069940562881722205193604550737455583875504348606989700013337656597740101535).instructions
(328, 4, 531, 4, 5, 0, 14)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L96-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.TMProgramme" href="#Main.ComputabilityTheory.TMProgramme"><code>Main.ComputabilityTheory.TMProgramme</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct TMProgramme &lt;: TuringMachine</code></pre><p>Fields:</p><ul><li><code>title::String</code>: A descriptive name for your programme.</li><li><code>initial::String</code>: The state name where the Turing machine begins.</li><li><code>final::String</code>: The state name where the Turing machine halts.</li><li><code>blank::String</code>: The symbol used to denote a blank cell.</li><li><code>Rules::Vector{Rule}</code>`: A list of rules of the programme.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L54-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{Type{GoToProgramme}, Integer}" href="#Base.rand-Tuple{Type{GoToProgramme}, Integer}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand(::Type{GoToProgramme}, d::Integer; upper_bound::Integer = 200)</code></pre><p>Finds a random go-to programme.</p><p><code>rand</code> takes in the type, <code>GoToProgramme</code>, a number of lines of the programme, <code>d</code>, and an upper bound for the main instructions (coded; not including the <code>halt</code> instruction) which defaults to 200.  (Recall how we code instructions, using <code>pair_tuple</code>, so numbers between 1 and 200 will produce reasonably small codes)</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><em>This may be slow</em>.  Depending on how large your upper bound is, it may take a while to find a valid code.</p></div></div><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; show_programme(rand(GoToProgramme, 3, upper_bound = 200)) # a reasonably small random programme with 3 lines
0    R3 := R3 + 1
1    if R0 = 0 goto 1
2    halt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L429-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MachineState}" href="#Base.show-Tuple{IO, MachineState}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, mstate::MachineState)</code></pre><p>Prints the current state of a Turing machine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.:∸-Tuple{Number, Number}" href="#Main.ComputabilityTheory.:∸-Tuple{Number, Number}"><code>Main.ComputabilityTheory.:∸</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated negation: an operator that acts like subtraction without going to negatives.</p><p>This can be written in the REPL as <code>\dotminus&lt;tab&gt;</code>.</p><p>Examples:</p><pre><code class="language-julia hljs">julia&gt; 6 ∸ 3
3

julia&gt; 3 ∸ 1
2

julia&gt; 10 ∸ 12
0

julia&gt; 1 ∸ 2
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/coding.jl#L8-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.cℤ-Tuple{Integer}" href="#Main.ComputabilityTheory.cℤ-Tuple{Integer}"><code>Main.ComputabilityTheory.cℤ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cℤ(z::Integer)
cℤ(z::Integer, w::Integer...)</code></pre><p>This function uniquely maps an integer to a natural number.  The output is a BigInt.  This function can be written in the REPL by <code>c\bbZ&lt;tab&gt;</code>.</p><p class="math-container">\[z \mapsto c\mathbb{Z}(z)\\
z, w, \ldots \mapsto c\mathbb{Z}(z), c\mathbb{Z}(w), \ldots\\
\mathbb{Z} \to \mathbb{N}\]</p><hr/><pre><code class="language-julia hljs">cℤ(zs::AbstractArray{&lt;:Integer})</code></pre><p>Given an array of integers, <code>cℤ</code> will convert every element of the array into natrual numbers.</p><hr/><pre><code class="language-julia hljs">cℤ(r::NTuple{N, Integer})</code></pre><p>Given a tuple, <code>cℤ</code> will convert ever element of the tuple into natural numbers, and pair the result:</p><p class="math-container">\[\left(z, w\right) \mapsto c\mathbb{Z}\left(\left\langle z, w\right\rangle\right)\\
\mathbb{Z}^2 \to \mathbb{N}\]</p><p class="math-container">\[\left(z_1, \ldots, z_n\right) \mapsto c\mathbb{Z}\left(\left\langle z_1\right\rangle\right), \ldots, c\mathbb{Z}\left(\left\langle z_n\right\rangle\right)\\
\mathbb{Z}^n \to \mathbb{N}\]</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; cℤ(-10) # code integer as a natural number
19

julia&gt; cℤ((-1,2)) # cℤ pairs the code of each
16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/coding.jl#L222-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.cℤ⁻¹-Tuple{Integer}" href="#Main.ComputabilityTheory.cℤ⁻¹-Tuple{Integer}"><code>Main.ComputabilityTheory.cℤ⁻¹</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cℤ⁻¹(n::Integer)</code></pre><p>The inverse of <code>cℤ⁻¹</code>.  Uniquely maps natural numbers to integers.  This function can be written in the REPL by <code>c\bbZ&lt;tab&gt;\^1&lt;tab&gt;</code>.</p><hr/><pre><code class="language-julia hljs">cℤ⁻¹(zs::AbstractArray{&lt;:Integer})</code></pre><p>Given an array of integers, <code>cℤ⁻¹</code> will convert every element of the array into integers.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; cℤ⁻¹(19)
-10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/coding.jl#L282-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.decrement-Tuple{Integer}" href="#Main.ComputabilityTheory.decrement-Tuple{Integer}"><code>Main.ComputabilityTheory.decrement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decrement(n::Integer)</code></pre><p>Constructs an <code>Instruction</code> object for decrementing the <span>$n\textsuperscript{th}$</span> register.</p><p>The code for &quot;<span>$Rn := Rn - 1$</span>&quot; is <span>$\left\langle 1, n\right\rangle$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L176-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.goto-Tuple{Integer}" href="#Main.ComputabilityTheory.goto-Tuple{Integer}"><code>Main.ComputabilityTheory.goto</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">goto(n::Integer)</code></pre><p>Constructs an <code>Instruction</code> object for going to line <span>$k$</span>.</p><p>The code for &quot;<span>$\texttt{goto } k$</span>&quot; is <span>$\left\langle 2, k\right\rangle$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L187-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.halt-Tuple{}" href="#Main.ComputabilityTheory.halt-Tuple{}"><code>Main.ComputabilityTheory.halt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">halt()</code></pre><p>Constructs an <code>Instruction</code> object for the final line of all goto programmes: <code>halt</code>.</p><p>The code for &quot;<span>$\texttt{halt}$</span>&quot; is <span>$\left\langle 4, 0\right\rangle$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L211-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.ifzero_goto-Tuple{Tuple{Integer, Integer}}" href="#Main.ComputabilityTheory.ifzero_goto-Tuple{Tuple{Integer, Integer}}"><code>Main.ComputabilityTheory.ifzero_goto</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifzero_goto(t::NTuple{2, Integer})
ifzero_goto(n::Integer, k::Integer)</code></pre><p>Constructs an <code>Instruction</code> object for going to line <span>$k$</span> if and only  if the <span>$n\textsuperscript{th}$</span> register is zero.</p><p>The code for &quot;<span>$\texttt{if } Rn = 0 \texttt{ goto } k$</span>&quot; is <span>$\left\langle 3, \left\langle n, k\right\rangle\right\rangle$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L198-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.increment-Tuple{Integer}" href="#Main.ComputabilityTheory.increment-Tuple{Integer}"><code>Main.ComputabilityTheory.increment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">increment(n::Integer)</code></pre><p>Constructs an <code>Instruction</code> object for incrementing the <span>$n\textsuperscript{th}$</span> register.</p><p>The code for &quot;<span>$Rn := Rn + 1$</span>&quot; is <span>$\left\langle 0, n\right\rangle$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.pair_tuple-Tuple{Integer, Integer}" href="#Main.ComputabilityTheory.pair_tuple-Tuple{Integer, Integer}"><code>Main.ComputabilityTheory.pair_tuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pair_tuple(x::Integer, y::Integer)
pair_tuple(x::Integer, y::Integer, z::Integer...)
pair_tuple(t::Tuple)</code></pre><p>The pairing function is a function that uniquely maps any number of integer inputs to a single integer:</p><p class="math-container">\[\left(k_1,k_2\right) \mapsto \frac{1}{2}\left(k_1+k_2\right)\left(k_1+k_2+1\right)+k_1\\
\mathbb{N}^2 \to \mathbb{N}\]</p><p>This concept can also be generalised to take integers <span>$x_0$</span> to <span>$x_{n-1}$</span> so that</p><p class="math-container">\[(x_0, x_1, \ldots, x_{n - 1}) \mapsto \left\langle\left\langle x_0, \ldots, x_{n - 2}\right\rangle, x_{n - 1}\right\rangle\\
\mathbb{N}^n \to \mathbb{N}\]</p><p>and returns their &quot;pair&quot;.</p><p>As this maps every combination of integers to a single output, this number gets massive very fast.  As such, <code>pair_tuple</code> will return a <code>BigInt</code>.</p><p>To depair the tuple, see <span>$\pi$</span>.</p><p>For more information, see <a href="https://en.m.wikipedia.org/wiki/Pairing_function">https://en.m.wikipedia.org/wiki/Pairing_function</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are two variations to this process <strong>which will change the output</strong>:</p><ul><li>As per the visualisation in the link above, the first number given is found along the <span>$x$</span> axis, and the second along the <span>$y$</span> axis.  <strong>In this implementation, it is the other way around.</strong>  This can easily by modified, however, by adding <span>$k_1$</span> at the end instead of <span>$k_2$</span>.</li><li>The other variation is which direction of nesting we decide on for more than 2 inputs.  The alternative (which <strong>we do not use in this implementation</strong>) is<p class="math-container">\[\left(x_0, x_1, \ldots, x_{n - 1}\right) \mapsto \left\langle x_0, \left\langle x_1, \ldots, x_{n - 1}\right\rangle\right\rangle\]</p></li></ul></div></div><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; pair_tuple(5,7) # code pair of natural numbers as a natural number
83</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/coding.jl#L37-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.rand_unsafe-Tuple{Type{GoToProgramme}, Integer}" href="#Main.ComputabilityTheory.rand_unsafe-Tuple{Type{GoToProgramme}, Integer}"><code>Main.ComputabilityTheory.rand_unsafe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_unsafe(::Type{GoToProgramme}, d::Integer; upper_bound::Integer = 200)</code></pre><p>Finds a random go-to programme.</p><p><code>rand_unsafe</code> takes in the type, <code>GoToProgramme</code>, a number of lines of the programme, <code>d</code>, and an upper bound for the main instructions (coded; not including the <code>halt</code> instruction) which defaults to 200.  (Recall how we code instructions, using <code>pair_tuple</code>, so numbers between 1 and 200 will produce reasonably small codes)</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>*This sometimes fails, as not every random number will deconstruct into a nice go-to programme.  Programmatically, I have done as much as I can to try to avoid this failing.  It is more likely to fail as you increase the upper bound.  To avoid this, try using <code>rand</code>, though be warned it might be a little slower as it will keep trying till it finds something.</p></div></div><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; show_programme(ComputabilityTheory.rand_unsafe(GoToProgramme, 3, upper_bound = 200)) # a reasonably small random programme with 3 lines
0    R3 := R3 + 1
1    if R0 = 0 goto 1
2    halt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L400-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.run_goto_programme-Tuple{GoToProgramme, RegisterMachine}" href="#Main.ComputabilityTheory.run_goto_programme-Tuple{GoToProgramme, RegisterMachine}"><code>Main.ComputabilityTheory.run_goto_programme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_goto_programme(P::GoToProgramme, R::RegisterMachine) -&gt; RegisterMachine.contents
run_goto_programme(P::GoToProgramme, T::Tuple) -&gt; RegisterMachine.contents
run_goto_programme(P::Integer, T::Tuple) -&gt; RegisterMachine.contents
run_goto_programme(P::Integer, R::RegisterMachine) -&gt; RegisterMachine.contents</code></pre><p>Takes in a <em>coded</em> programme <code>P</code> (for coding a programme, see notes), and runs the programme using register machine R.  It a tuple is given, will convert to a register machine whose contents is the tuple.  If an integer is given, will convert to a goto programme.</p><p>Notes: There are five possible instructions for a GoTo programme:</p><ul><li>Increment Rᵢ  ⟵ <code>pair_tuple(0, i)</code></li><li>Decrement Rᵢ  ⟵ <code>pair_tuple(1, i)</code></li><li>Goto line k  ⟵ <code>pair_tuple(2, k)</code></li><li>If Rᵢ is zero, goto line k  ⟵ <code>pair_tuple(3, (i, k))</code></li><li>Halt  ⟵ <code>pair_tuple(4, 0)</code></li></ul><p>Then, the programme P, consisting of instructions I₁, I₂, ..., Iᵢ, is coded by</p><pre><code class="language-julia hljs">pair_tuple(i, pair_tuple(I₁, I₂, ..., Iᵢ))</code></pre><p>For utilities regarding these instructions, see <code>pair_tuple</code>, <code>Sequence</code>, <code>Instruction</code>, <code>increment</code>, <code>decrement</code>, <code>goto</code>, <code>ifzero_goto</code>, <code>halt</code>, and <code>GoToProgramme</code>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; run_goto_programme(363183787614755732766753446033240)
(1, 0)

julia&gt; run_goto_programme(363183787614755732766753446033240, Register(0, 0, 0 ,0))
(1, 0, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L175-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.run_turing_machine-Tuple{Any, Any, Any}" href="#Main.ComputabilityTheory.run_turing_machine-Tuple{Any, Any, Any}"><code>Main.ComputabilityTheory.run_turing_machine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_turing_machine(TMProgramme, tape, verbose)</code></pre><p>Run a specified Turing programme on a specified tape.  <code>verbose</code> is a boolean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/machines.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.ComputabilityTheory.show_programme-Tuple{IO, GoToProgramme}" href="#Main.ComputabilityTheory.show_programme-Tuple{IO, GoToProgramme}"><code>Main.ComputabilityTheory.show_programme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_programme(io::IO, P::GoToProgramme)
show_programme(P::GoToProgramme)
show_programme(P::Integer)</code></pre><p>Given a goto programme, this function will decode it into its constituent components.  It will default to <code>stdout</code>.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; show_programme(121)
0    halt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/ComputabilityTheory.jl/blob/1aea8cf2988382c75f91aad653a863ffcf527072/src/goto.jl#L333-L350">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Base.MathConstants.π-Tuple{Vararg{Integer}}"><code>Base.MathConstants.π</code></a></li><li><a href="#Main.ComputabilityTheory.GoToProgramme"><code>Main.ComputabilityTheory.GoToProgramme</code></a></li><li><a href="#Main.ComputabilityTheory.Instruction"><code>Main.ComputabilityTheory.Instruction</code></a></li><li><a href="#Main.ComputabilityTheory.MachineState"><code>Main.ComputabilityTheory.MachineState</code></a></li><li><a href="#Main.ComputabilityTheory.Move"><code>Main.ComputabilityTheory.Move</code></a></li><li><a href="#Main.ComputabilityTheory.RegisterMachine"><code>Main.ComputabilityTheory.RegisterMachine</code></a></li><li><a href="#Main.ComputabilityTheory.Rule"><code>Main.ComputabilityTheory.Rule</code></a></li><li><a href="#Main.ComputabilityTheory.Sequence"><code>Main.ComputabilityTheory.Sequence</code></a></li><li><a href="#Main.ComputabilityTheory.TMProgramme"><code>Main.ComputabilityTheory.TMProgramme</code></a></li><li><a href="#Base.rand-Tuple{Type{GoToProgramme}, Integer}"><code>Base.rand</code></a></li><li><a href="#Base.show-Tuple{IO, MachineState}"><code>Base.show</code></a></li><li><a href="#Main.ComputabilityTheory.:∸-Tuple{Number, Number}"><code>Main.ComputabilityTheory.:∸</code></a></li><li><a href="#Main.ComputabilityTheory.cℤ-Tuple{Integer}"><code>Main.ComputabilityTheory.cℤ</code></a></li><li><a href="#Main.ComputabilityTheory.cℤ⁻¹-Tuple{Integer}"><code>Main.ComputabilityTheory.cℤ⁻¹</code></a></li><li><a href="#Main.ComputabilityTheory.decrement-Tuple{Integer}"><code>Main.ComputabilityTheory.decrement</code></a></li><li><a href="#Main.ComputabilityTheory.goto-Tuple{Integer}"><code>Main.ComputabilityTheory.goto</code></a></li><li><a href="#Main.ComputabilityTheory.halt-Tuple{}"><code>Main.ComputabilityTheory.halt</code></a></li><li><a href="#Main.ComputabilityTheory.ifzero_goto-Tuple{Tuple{Integer, Integer}}"><code>Main.ComputabilityTheory.ifzero_goto</code></a></li><li><a href="#Main.ComputabilityTheory.increment-Tuple{Integer}"><code>Main.ComputabilityTheory.increment</code></a></li><li><a href="#Main.ComputabilityTheory.pair_tuple-Tuple{Integer, Integer}"><code>Main.ComputabilityTheory.pair_tuple</code></a></li><li><a href="#Main.ComputabilityTheory.rand_unsafe-Tuple{Type{GoToProgramme}, Integer}"><code>Main.ComputabilityTheory.rand_unsafe</code></a></li><li><a href="#Main.ComputabilityTheory.run_goto_programme-Tuple{GoToProgramme, RegisterMachine}"><code>Main.ComputabilityTheory.run_goto_programme</code></a></li><li><a href="#Main.ComputabilityTheory.run_turing_machine-Tuple{Any, Any, Any}"><code>Main.ComputabilityTheory.run_turing_machine</code></a></li><li><a href="#Main.ComputabilityTheory.show_programme-Tuple{IO, GoToProgramme}"><code>Main.ComputabilityTheory.show_programme</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 7 November 2022 03:27">Monday 7 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
